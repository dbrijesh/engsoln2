name: Application - Deploy to AKS

on:
  workflow_run:
    workflows: ["Frontend - Build & Test", "Backend - Build & Test"]
    types:
      - completed
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - dev
          - stage
          - prod
      frontend_tag:
        description: 'Frontend image tag (default: latest)'
        required: false
        default: 'latest'
      backend_tag:
        description: 'Backend image tag (default: latest)'
        required: false
        default: 'latest'

jobs:
  deploy-to-dev:
    name: Deploy to Dev
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'dev')
    environment:
      name: dev
      url: https://dev-${{ vars.DOMAIN_NAME }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ vars.AKS_RESOURCE_GROUP_DEV }} \
            --name ${{ vars.AKS_CLUSTER_NAME_DEV }} \
            --overwrite-existing

      - name: Create namespace if not exists
        run: |
          kubectl create namespace dev --dry-run=client -o yaml | kubectl apply -f -

      - name: Install NGINX Ingress Controller
        run: |
          # Install NGINX Ingress Controller if not already installed
          if ! kubectl get namespace ingress-nginx &> /dev/null; then
            helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
            helm repo update
            helm install ingress-nginx ingress-nginx/ingress-nginx \
              --create-namespace \
              --namespace ingress-nginx \
              --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz
            echo "Waiting for ingress controller to be ready..."
            kubectl wait --namespace ingress-nginx \
              --for=condition=ready pod \
              --selector=app.kubernetes.io/component=controller \
              --timeout=300s
          else
            echo "NGINX Ingress Controller already installed"
          fi

      - name: Install cert-manager
        run: |
          # Install cert-manager if not already installed
          if ! kubectl get namespace cert-manager &> /dev/null; then
            kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.yaml
            echo "Waiting for cert-manager to be ready..."
            kubectl wait --for=condition=Available --timeout=300s -n cert-manager deployment/cert-manager
            kubectl wait --for=condition=Available --timeout=300s -n cert-manager deployment/cert-manager-webhook
            kubectl wait --for=condition=Available --timeout=300s -n cert-manager deployment/cert-manager-cainjector
          else
            echo "cert-manager already installed"
          fi

      - name: Create self-signed ClusterIssuer
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: selfsigned-issuer
          spec:
            selfSigned: {}
          EOF

      - name: Create image pull secret
        run: |
          kubectl create secret docker-registry acr-secret \
            --docker-server=${{ secrets.ACR_LOGIN_SERVER }} \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace dev \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create Azure AD secrets
        run: |
          kubectl create secret generic azure-ad-credentials \
            --from-literal=client-id=${{ secrets.BACKEND_CLIENT_ID }} \
            --from-literal=tenant-id=${{ secrets.ARM_TENANT_ID }} \
            --namespace dev \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Backend
        run: |
          # Set environment variables for manifest substitution
          export ACR_LOGIN_SERVER="${{ secrets.ACR_LOGIN_SERVER }}"
          export IMAGE_TAG="${{ github.event.inputs.backend_tag || 'latest' }}"
          export BACKEND_IP="backend-ip-placeholder"

          # Apply backend deployment and service (no IP substitution needed)
          envsubst < k8s/dev/backend-deployment.yaml | kubectl apply -f -
          kubectl apply -f k8s/dev/backend-service.yaml

      - name: Deploy Backend Ingress
        id: backend-ingress
        run: |
          # Deploy backend ingress (works with IP-based access, no host required)
          kubectl apply -f k8s/dev/backend-ingress.yaml

          # Wait for ingress to get external IP from LoadBalancer
          echo "Waiting for backend ingress IP..."
          for i in {1..30}; do
            BACKEND_IP=$(kubectl get ingress backend -n dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ -n "$BACKEND_IP" ]; then
              echo "Backend Ingress IP: $BACKEND_IP"
              echo "backend_ip=$BACKEND_IP" >> $GITHUB_OUTPUT
              break
            fi
            echo "Waiting for ingress IP... ($i/30)"
            sleep 10
          done
          if [ -z "$BACKEND_IP" ]; then
            echo "Warning: Backend ingress IP not available yet, using service name"
            echo "backend_ip=backend.dev.svc.cluster.local" >> $GITHUB_OUTPUT
          fi

      - name: Deploy Frontend
        run: |
          # Set environment variables for manifest substitution
          export ACR_LOGIN_SERVER="${{ secrets.ACR_LOGIN_SERVER }}"
          export IMAGE_TAG="${{ github.event.inputs.frontend_tag || 'latest' }}"
          export REACT_APP_CLIENT_ID="${{ secrets.REACT_APP_CLIENT_ID }}"
          export REACT_APP_TENANT_ID="${{ secrets.ARM_TENANT_ID }}"
          export REACT_APP_API_URL="https://${{ steps.backend-ingress.outputs.backend_ip }}"
          export REACT_APP_API_SCOPE="api://${{ secrets.BACKEND_CLIENT_ID }}/access_as_user"

          # Apply frontend deployment and service
          envsubst < k8s/dev/frontend-deployment.yaml | kubectl apply -f -
          kubectl apply -f k8s/dev/frontend-service.yaml

      - name: Deploy Frontend Ingress
        run: |
          # Deploy frontend ingress (works with IP-based access, no host required)
          kubectl apply -f k8s/dev/frontend-ingress.yaml

          # Wait for frontend ingress IP
          echo "Waiting for frontend ingress IP..."
          for i in {1..30}; do
            FRONTEND_IP=$(kubectl get ingress frontend -n dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ -n "$FRONTEND_IP" ]; then
              echo "Frontend Ingress IP: $FRONTEND_IP"
              break
            fi
            echo "Waiting for ingress IP... ($i/30)"
            sleep 10
          done

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/backend -n dev --timeout=5m
          kubectl rollout status deployment/frontend -n dev --timeout=5m

      - name: Run smoke tests
        run: |
          echo "Running smoke tests..."

          # Wait for services to be ready
          sleep 30

          # Get backend service endpoint
          BACKEND_IP=$(kubectl get svc backend -n dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

          # Test backend health endpoint
          if [ -n "$BACKEND_IP" ]; then
            curl -f http://$BACKEND_IP/actuator/health || echo "Backend health check failed"
          else
            echo "Backend service IP not found, checking via port-forward..."
            kubectl port-forward -n dev svc/backend 8080:8080 &
            sleep 5
            curl -f http://localhost:8080/actuator/health || echo "Backend health check failed"
            pkill -f "port-forward"
          fi

      - name: Get deployment status
        if: always()
        run: |
          echo "## Deployment Status - Dev Environment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get Ingress IPs
          FRONTEND_IP=$(kubectl get ingress frontend -n dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "Pending...")
          BACKEND_IP=$(kubectl get ingress backend -n dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "Pending...")

          echo "### Access URLs (HTTPS with Self-Signed Certificates)" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend**: https://$FRONTEND_IP" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend API**: https://$BACKEND_IP" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend Health**: https://$BACKEND_IP/actuator/health" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **Note**: HTTPS uses self-signed certificates. Accept the certificate warning in your browser." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Pods" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n dev >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Ingress (IP-based with TLS)" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get ingress -n dev >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Certificates" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get certificates -n dev 2>/dev/null || echo "No certificates found"
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  deploy-to-stage:
    name: Deploy to Stage
    runs-on: ubuntu-latest
    needs: deploy-to-dev
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'stage'
    environment:
      name: stage
      url: https://stage-${{ vars.DOMAIN_NAME }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ vars.AKS_RESOURCE_GROUP_STAGE }} \
            --name ${{ vars.AKS_CLUSTER_NAME_STAGE }} \
            --overwrite-existing

      - name: Create namespace if not exists
        run: |
          kubectl create namespace stage --dry-run=client -o yaml | kubectl apply -f -

      - name: Create image pull secret
        run: |
          kubectl create secret docker-registry acr-secret \
            --docker-server=${{ secrets.ACR_LOGIN_SERVER }} \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace stage \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create Azure AD secrets
        run: |
          kubectl create secret generic azure-ad-credentials \
            --from-literal=client-id=${{ secrets.BACKEND_CLIENT_ID }} \
            --from-literal=tenant-id=${{ secrets.ARM_TENANT_ID }} \
            --namespace stage \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Backend with Helm
        run: |
          helm upgrade --install backend ./charts/backend \
            --namespace stage \
            --set image.repository=${{ secrets.ACR_LOGIN_SERVER }}/aks-starter-backend \
            --set image.tag=${{ github.event.inputs.backend_tag || 'latest' }} \
            --set replicaCount=3 \
            --set ingress.enabled=true \
            --set ingress.hosts[0].host=stage-api-${{ vars.DOMAIN_NAME }} \
            --wait \
            --timeout 5m

      - name: Deploy Frontend with Helm
        run: |
          helm upgrade --install frontend ./charts/frontend \
            --namespace stage \
            --set image.repository=${{ secrets.ACR_LOGIN_SERVER }}/aks-starter-frontend \
            --set image.tag=${{ github.event.inputs.frontend_tag || 'latest' }} \
            --set replicaCount=3 \
            --set ingress.enabled=true \
            --set ingress.hosts[0].host=stage-${{ vars.DOMAIN_NAME }} \
            --wait \
            --timeout 5m

      - name: Run integration tests
        run: |
          echo "Running integration tests on stage environment..."
          # Add your integration test commands here

  deploy-to-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: deploy-to-stage
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod'
    environment:
      name: prod
      url: https://${{ vars.DOMAIN_NAME }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ vars.AKS_RESOURCE_GROUP_PROD }} \
            --name ${{ vars.AKS_CLUSTER_NAME_PROD }} \
            --overwrite-existing

      - name: Create namespace if not exists
        run: |
          kubectl create namespace prod --dry-run=client -o yaml | kubectl apply -f -

      - name: Create image pull secret
        run: |
          kubectl create secret docker-registry acr-secret \
            --docker-server=${{ secrets.ACR_LOGIN_SERVER }} \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace prod \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create Azure AD secrets
        run: |
          kubectl create secret generic azure-ad-credentials \
            --from-literal=client-id=${{ secrets.BACKEND_CLIENT_ID }} \
            --from-literal=tenant-id=${{ secrets.ARM_TENANT_ID }} \
            --namespace prod \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Backend with Helm
        run: |
          helm upgrade --install backend ./charts/backend \
            --namespace prod \
            --set image.repository=${{ secrets.ACR_LOGIN_SERVER }}/aks-starter-backend \
            --set image.tag=${{ github.event.inputs.backend_tag || 'latest' }} \
            --set replicaCount=5 \
            --set resources.requests.memory=512Mi \
            --set resources.requests.cpu=500m \
            --set resources.limits.memory=1Gi \
            --set resources.limits.cpu=1000m \
            --set autoscaling.enabled=true \
            --set autoscaling.minReplicas=3 \
            --set autoscaling.maxReplicas=15 \
            --set ingress.enabled=true \
            --set ingress.hosts[0].host=api-${{ vars.DOMAIN_NAME }} \
            --wait \
            --timeout 10m

      - name: Deploy Frontend with Helm
        run: |
          helm upgrade --install frontend ./charts/frontend \
            --namespace prod \
            --set image.repository=${{ secrets.ACR_LOGIN_SERVER }}/aks-starter-frontend \
            --set image.tag=${{ github.event.inputs.frontend_tag || 'latest' }} \
            --set replicaCount=5 \
            --set autoscaling.enabled=true \
            --set autoscaling.minReplicas=3 \
            --set autoscaling.maxReplicas=10 \
            --set ingress.enabled=true \
            --set ingress.hosts[0].host=${{ vars.DOMAIN_NAME }} \
            --wait \
            --timeout 10m

      - name: Wait for rollout and monitor
        run: |
          kubectl rollout status deployment/backend -n prod --timeout=10m
          kubectl rollout status deployment/frontend -n prod --timeout=10m

          echo "Monitoring for 2 minutes..."
          sleep 120

      - name: Production smoke tests
        run: |
          echo "Running production smoke tests..."
          # Add production-specific smoke tests here

      - name: Send deployment notification
        if: success()
        run: |
          echo "## ðŸš€ Production Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Production" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend Tag**: ${{ github.event.inputs.backend_tag || 'latest' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Tag**: ${{ github.event.inputs.frontend_tag || 'latest' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed At**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: https://${{ vars.DOMAIN_NAME }}" >> $GITHUB_STEP_SUMMARY
